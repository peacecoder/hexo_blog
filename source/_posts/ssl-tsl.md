---
title: ssl_tsl
date: 2016-07-08 11:56:21
tags: ssl, tsl, security, web
---


# SSL & TSL 原理

## 安全通信背景

在介绍SSL 以及 TSL
之前我们必须了解[公钥加密方法](https://en.wikipedia.org/wiki/Public-key_cryptography)。这个方法其实很简单，意思是利用加密算法生成一对钥匙和锁，可以把公钥认为是锁，私钥认为是钥匙。生成了这个工具之后，就可以把锁（公钥）公布出去，其他人利用这个锁将数据进行加密。然后可以传输该加密信息，只有掌握了钥匙（私钥）的一方才能对这些加密的信息进行解密。

介绍完公钥加密方法之后我们自然有一个疑问，客户端与服务端双方如何通过HTTP请求以及公钥加密算法实现加密通信呢？一个显而易见的想法就是服务端生成公钥和私钥，客户端请求公钥，服务端将公钥交给客户端，客户端拿到这个公钥之后加密数据并传输，服务端收到这个加密数据用私钥解密之后做相应的处理。这一切都显得很美妙，不过存在一个实际问题。这个问题是由公钥算法带来的，一般来说我们为了保证加密算法的安全性，采用的加密算法比较复杂，如果客户端每次都使用公钥加密的话，那么数据通信效率将受到加密算法效率的影响，而且该影响基本肯定是负向的。那么有什么方法解决这个问题呢？

聪明的前人自然不会让我们失望。如果使用公钥加密算法太复杂，我们可以采用其他加密方式，比如说[对称加密算法](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)（高效）。

引入对成加密算法之后也带来新的问题。对成加密算法要求双方都使用相同的密钥进行加密解密。如何保证通信双方能够安全的获取对应的密钥呢？其实答案已经在我们的公钥加密算法中了，对称密钥算法可以解决公钥加密算法的低效，反过来公钥加密算法可以解决对称密钥算法需要传输相同密钥的缺点。因此，两种加密算法正好形成互补。

## SSL/TSL 通信过程

通过上述的介绍，我们现在来详细解释一下SSL／TSL通信的详细过程，如下所示：
1. 客户端向服务发起请求，该请求中包含的内容：支持安全协议版本，一个客户端生成的随机数（用于对称加密），支持的加密算法，例如RSA公钥加密，支持的压缩算法。
2. 服务端收到客户端请求之后，向客户端返回响应，内容包括：确认使用安全协议的版本，一个服务器生成的随机数（同样用于对称加密），确认使用加密算法，服务器证书（就是服务端利用公钥加密算法生成的公钥）
3.
客户端收到服务的响应之后，向服务端再次发起请求，内容包括：使用服务端提供的证书加密随机数（新的随机数，同样用于对称加密算法），编码改变通知（表示随后的信息都使用双方商定的加密方法和密钥发送，其实就是说使用对称加密算法进行通信），客户端握手结束通知，表示客户端的握手阶段已经结束（这一项同时也是前面发送的所有内容的hash值，用来供服务器校验）。
4. 服务端最后的响应，包括，编码改变通知（表示随后的信息都将用双方商定的加密方法和密钥发送），服务器握手结束通知，表示服务器的握手阶段已经结束（这一项同时也是前面发送的所有内容的hash值，用来供客户端校验）。

此后客户端用对称加密算法对数据进行加密，然后通过http协议向服务端发送加密后的数据。服务端收到加密数据，使用对称加密算法对其进行解密。这一前提是双方都掌握了三个随机数。

问题来了，为什么要采用三个随机数呢？使用三个随机数的原因是基于服务端不信任客户端能够产生真正的随机数，如果只是伪随机数的话，那么还是有可能被破解。通过服务端生成的随机数，加上客户端的两个随机数，其中一个用公钥加密，能够最大近似真实随机数。利用这个三个随机数导出的对称密钥可以保证安全。


## 参考

1. [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html?20160707190413#comment-last)
2. [图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
3. [对称密钥加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)
4. [公钥加密](https://en.wikipedia.org/wiki/Public-key_cryptography)

